---
description: 
globs: 
alwaysApply: true
---
# Cursor Development Rules & AI Collaboration Guide (Python Backend + Electron Frontend)

## üìú Core Philosophy

1.  **Simplicity:** Prioritize simple, clear, and maintainable solutions. Avoid unnecessary complexity or over-engineering in both Python and Electron code.
2.  **Iterate:** Prefer iterating on existing, working code rather than building entirely new solutions from scratch, unless fundamentally necessary or explicitly requested.
3.  **Focus:** Concentrate efforts on the specific task assigned. Avoid unrelated changes or scope creep across backend and frontend.
4.  **Quality:** Strive for a clean, organized, well-tested, and secure codebase in both Python and JavaScript/HTML/CSS.
5.  **Collaboration:** This document guides both human developers and the AI assistant for effective teamwork.

## üìö Project Context & Understanding

1.  **Documentation First:**
    *   **Always** check for and thoroughly review relevant project documentation *before* starting any task. This includes:
        *   Product Requirements Documents (PRDs)
        *   `README.md` (Project overview, setup, patterns, technology stack - Python version, Node version, Electron specifics, frontend framework if any)
        *   `docs/architecture.md` (System architecture, component relationships, **Backend API design**, **Electron process model (main/renderer)**, data flow)
        *   `docs/technical.md` (Technical specifications, established patterns for Python backend and Electron frontend)
        *   `tasks/tasks.md` (Current development tasks, requirements)
    *   If documentation is missing, unclear, or conflicts with the request, **ask for clarification**.
2.  **Architecture Adherence:**
    *   Understand and respect module boundaries (Python packages/modules, Electron processes), data flow (API contracts, IPC messages), system interfaces, and component dependencies outlined in `docs/architecture.md`.
    *   Validate that changes comply with the established architecture. Warn and propose compliant solutions if a violation is detected.
3.  **Pattern & Tech Stack Awareness:**
    *   Reference `README.md` and `docs/technical.md` to understand and utilize existing patterns (e.g., backend ORM, API design style, frontend state management, Electron IPC patterns) and technologies.
    *   Exhaust options using existing implementations before proposing new patterns or libraries (Python packages, Node modules).

## ‚öôÔ∏è Task Execution & Workflow

1.  **Task Definition:**
    *   Clearly understand the task requirements, acceptance criteria, and any dependencies from `tasks/tasks.md` and the PRD. Determine if the task primarily involves the backend, frontend, or both.
2.  **Systematic Change Protocol:** Before making significant changes:
    *   **Identify Impact:** Determine affected components (Python modules, API endpoints, Electron processes, UI views), dependencies, and potential side effects.
    *   **Plan:** Outline the steps. Tackle one logical change or file at a time. Consider backend API changes first if the frontend depends on them.
    *   **Verify Testing:** Confirm how the change will be tested (backend unit/integration tests, frontend tests, end-to-end tests). Add tests if necessary *before* implementing.
3.  **Progress Tracking:**
    *   Keep `docs/status.md` updated with task progress (in-progress, completed, blocked), issues encountered, and completed items.
    *   Update `tasks/tasks.md` upon task completion or if requirements change during implementation.

## ü§ñ AI Collaboration & Prompting

1.  **Clarity is Key:** Provide clear, specific, and unambiguous instructions to the AI. Define the desired outcome, constraints, and context (e.g., "Modify the Python API endpoint...", "Update the Electron renderer process code...").
2.  **Context Referencing:** If a task spans multiple interactions, explicitly remind the AI of relevant previous context, decisions, or code snippets (Python or JavaScript).
3.  **Suggest vs. Apply:** Clearly state whether the AI should *suggest* a change for human review or *apply* a change directly (use only when high confidence and task is well-defined). Use prefixes like "Suggestion:" or "Applying fix:".
4.  **Question AI Output:** Human developers should critically review AI-generated code (Python and JavaScript). Question assumptions, verify logic (especially around IPC and API interactions), and don't blindly trust confident-sounding but potentially incorrect suggestions.
5.  **Focus the AI:** Guide the AI to work on specific, focused parts of the task (e.g., a single Python function, an Electron event handler). Avoid overly broad requests that might lead to architectural or logical errors.
6.  **Leverage Strengths:** Use the AI for tasks it excels at (boilerplate generation for Python classes or Electron handlers, refactoring specific patterns, finding syntax errors, generating test cases) but maintain human oversight for complex logic, architecture, security, and IPC design.
7.  **Incremental Interaction:** Break down complex tasks into smaller steps for the AI. Review and confirm each step before proceeding.
8.  **Standard Check-in (for AI on large tasks):** Before providing significant code suggestions:
    *   "Confirming understanding: I've reviewed [specific document/previous context]. The goal is [task goal], adhering to [key pattern/constraint like Python API spec or Electron security model]. Proceeding with [planned step]."

## ‚ú® Code Quality & Style

1.  **Python Guidelines:** Use type hinting (`mypy` recommended). Follow PEP 8. Document complex logic or public APIs/functions with docstrings (Google or NumPy style preferred, be consistent). Use virtual environments (`venv` or `conda`).
2.  **Electron/JavaScript Guidelines:** Use modern JavaScript (ES6+). Document complex logic or public APIs with JSDoc. Consider using TypeScript for better type safety in frontend/renderer code if feasible. Follow Electron security best practices (e.g., `contextIsolation: true`, `sandbox: true`).
3.  **Readability & Maintainability:** Write clean, well-organized code in both languages.
4.  **Small Files & Components:**
    *   Keep Python files focused and reasonably sized (aim under 300-400 lines). Refactor large modules.
    *   Keep JavaScript files focused. Break down large UI components (if using a framework) or complex logic blocks into smaller, single-responsibility units.
5.  **Avoid Duplication (DRY):** Actively look for and reuse existing functionality in both backend and frontend. Refactor to eliminate duplication.
6.  **Linting/Formatting:** Ensure all code conforms to project's linters/formatters (e.g., Black, Flake8, MyPy for Python; ESLint, Prettier for JavaScript).
7.  **Pattern Consistency:** Adhere to established project patterns (API design, data handling, IPC messaging, state management). Don't introduce new ones without discussion/explicit instruction. If replacing an old pattern, ensure the old implementation is fully removed.
8.  **File Naming:** Use clear, descriptive names (snake_case for Python, camelCase or kebab-case for JS/HTML/CSS as per convention). Avoid "temp", "refactored", "improved", etc., in permanent file names.
9.  **No One-Time Scripts:** Do not commit one-time utility scripts into the main codebase.

## ‚ôªÔ∏è Refactoring

1.  **Purposeful Refactoring:** Refactor to improve clarity, reduce duplication, simplify complexity, or adhere to architectural goals in either backend or frontend.
2.  **Holistic Check:** When refactoring, look for duplicate code, similar components/files/modules, and opportunities for consolidation across the affected area (Python or JS).
3.  **Edit, Don't Copy:** Modify existing files directly. Do not duplicate files and rename them (e.g., `api_handler_v2.py`, `component-v2.js`).
4.  **Verify Integrations:** After refactoring, ensure all callers (API consumers, IPC listeners/senders), dependencies, and integration points function correctly. Run relevant tests (backend, frontend, E2E).

## ‚úÖ Testing & Validation

1.  **Test-Driven Development (TDD) Approach:**
    *   **New Features:** Outline tests (Python unit/integration tests for API, JS unit/integration tests for frontend logic, E2E tests for user flows), write failing tests, implement code, refactor.
    *   **Bug Fixes:** Write a test reproducing the bug *before* fixing it (in the relevant backend or frontend test suite).
2.  **Comprehensive Tests:** Write thorough tests covering critical paths, edge cases, API contracts, IPC message handling, and major functionality. Use appropriate frameworks (e.g., `pytest` for Python, Jest/Vitest for JS).
3.  **Tests Must Pass:** All relevant tests **must** pass before committing or considering a task complete. Notify the human developer immediately if tests fail and cannot be easily fixed.
4.  **No Mock Data (Except Tests):** Use mock data *only* within test environments (mocking API responses for frontend tests, mocking external services for backend tests). Development should use real or realistic data sources.
5.  **Manual Verification:** Supplement automated tests with manual checks, especially for UI changes and cross-process interactions in Electron.

## üêõ Debugging & Troubleshooting

1.  **Fix the Root Cause:** Prioritize fixing the underlying issue causing an error (in backend logic, frontend code, or IPC), rather than just masking or handling it, unless a temporary workaround is explicitly agreed upon.
2.  **Console/Log Analysis:** Always check **both** the Python server logs/console output and the Electron main/renderer process console output (via Developer Tools) for errors, warnings, or relevant logs. Report findings.
3.  **Targeted Logging:** For persistent or complex issues, add specific logging statements (`logging` module in Python, `console.log` in JS) to trace execution and variable states across processes. *Remember to check the output.*
4.  **Check the `fixes/` Directory:** Before deep-diving into a complex or recurring bug, check `fixes/` for documented solutions to similar past issues.
5.  **Document Complex Fixes:** If a bug requires significant effort (multiple iterations, complex logic) to fix, create a concise `.md` file in the `fixes/` directory detailing the problem, investigation steps, and the solution. Name it descriptively (e.g., `fixes/resolve-ipc-deadlock-on-data-sync.md`).
6.  **Research:** Use available tools (documentation search, web search) to research solutions or best practices for Python, Electron, or specific libraries when stuck or unsure.

## üîí Security

1.  **Server-Side Authority:** Keep sensitive logic, validation, and data manipulation strictly on the Python backend. Use secure API endpoints.
2.  **Input Sanitization/Validation:** Always sanitize and validate user input on the **server-side (Python)**. Validate data received via IPC in Electron's main process as well.
3.  **Electron Security:** Follow Electron security guidelines rigorously (`contextIsolation`, `sandbox`, disable `nodeIntegration` in renderers, validate IPC messages). Be cautious about loading remote content.
4.  **Dependency Awareness:** Be mindful of the security implications of adding or updating dependencies (`requirements.txt`/`pyproject.toml` for Python, `package.json` for Node/Electron). Regularly audit dependencies if possible.
5.  **Credentials:** Never hardcode secrets or credentials in the codebase (Python or JS). Use environment variables or a secure secrets management solution accessible by the Python backend.

## üå≥ Version Control & Environment

1.  **Git Hygiene:**
    *   Commit frequently with clear, atomic messages describing changes (e.g., "feat(api): Add user creation endpoint", "fix(ui): Correct button alignment").
    *   Keep the working directory clean; ensure no unrelated or temporary files (`__pycache__`, `node_modules`, build artifacts, `.env`) are staged or committed.
    *   Use `.gitignore` effectively for Python (`*.pyc`, `__pycache__/`, `.venv/`, `*.env`), Node/Electron (`node_modules/`, `dist/`, `build/`, `*.env`), and OS files (`.DS_Store`, `Thumbs.db`).
2.  **Branching Strategy:** Follow the project's established branching strategy. Do not create new branches unless requested or necessary for the workflow.
3.  **.env Files:** **Never** commit `.env` files containing secrets. Use `.env.example` for templates. Do not overwrite local `.env` files without confirmation.
4.  **Environment Awareness:** Code should function correctly across different environments (dev, test, prod). Use environment variables for configuration (backend API URLs, database connections, etc.).
5.  **Server/App Management:** Ensure the Python backend server is running correctly. Kill related running servers/Electron apps before starting new ones if necessary. Restart servers/app after relevant configuration or backend/main process changes. Manage Python virtual environments and Node dependencies correctly.

## üìÑ Documentation Maintenance

1.  **Update Docs:** If code changes impact architecture (API changes, IPC contracts, Electron process model), technical decisions, established patterns, or task status, update the relevant documentation (`README.md`, `docs/architecture.md`, `docs/technical.md`, `tasks/tasks.md`, `docs/status.md`). Document API changes clearly.
2.  **Keep Rules Updated:** This `.cursorrules` file should be reviewed and updated periodically to reflect learned best practices and project evolution specific to the Python/Electron stack.
